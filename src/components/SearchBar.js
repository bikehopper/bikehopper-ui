import * as React from 'react';
import { useDispatch, useSelector, shallowEqual } from 'react-redux';
import Icon from './Icon';
import SearchAutocompleteDropdown from './SearchAutocompleteDropdown';
import { geocodeTypedLocation } from '../features/geocoding';
import {
  locationInputFocused,
  locationInputsBlurred,
  locationsSubmitted,
  LocationSourceType,
  selectGeocodedLocation,
} from '../features/locations';
import describePlace from '../lib/describePlace';
import { ReactComponent as Pin } from 'iconoir/icons/pin-alt.svg';

import './SearchBar.css';

export default function SearchBar(props) {
  const dispatch = useDispatch();

  // Locations that (if set) we already have coordinates for, and may have a
  // route between. Global state.
  const { startLocation, endLocation } = useSelector(
    (state) => ({
      startLocation: state.locations.start,
      endLocation: state.locations.end,
    }),
    shallowEqual,
  );

  // Text the user is entering representing a location, but we may not have
  // coordinates for it yet. Local state, overlay over global location state.
  // If one of these is empty string or equal to the autogenerated description
  // of a geocoded location, fall back to the global location state.
  const [startText, setStartText] = React.useState('');
  const [endText, setEndText] = React.useState('');
  const [startHasLocalEdits, setStartHasLocalEdits] = React.useState(false);
  const [endHasLocalEdits, setEndHasLocalEdits] = React.useState(false);

  const [focusedInput, setFocusedInput] = React.useState(null); // can be 'start' or 'end'

  const formRef = React.useRef();
  const startRef = React.useRef();
  const endRef = React.useRef();

  // When global location state changes in certain ways, reset local state.
  React.useEffect(() => {
    if (!startLocation) return;
    if (startLocation.source === LocationSourceType.Geocoded) {
      setStartText(describePlace(startLocation.point));
    } else {
      setStartText('');
    }
    setStartHasLocalEdits(false);
  }, [startLocation]);
  React.useEffect(() => {
    if (!endLocation) return;
    if (endLocation.source === LocationSourceType.Geocoded) {
      setEndText(describePlace(endLocation.point));
    } else {
      setEndText('');
    }
    setEndHasLocalEdits(false);
  }, [endLocation]);

  // For each input that ISN'T focused and is empty, display text indicating
  // that the location is Current Location or a dragged point, if applicable.
  let displayedStart = startText;
  if (!startText && !startHasLocalEdits && focusedInput !== 'start')
    displayedStart = _describeLocation(startLocation);
  let displayedEnd = endText;
  if (!endText && !endHasLocalEdits && focusedInput !== 'end')
    displayedEnd = _describeLocation(endLocation);

  const handleStartChange = (evt) => {
    const text = evt.target.value;
    setStartText(text);
    setStartHasLocalEdits(true);
    dispatch(geocodeTypedLocation(text, 'start', { possiblyIncomplete: true }));
  };

  const handleEndChange = (evt) => {
    const text = evt.target.value;
    setEndText(text);
    setEndHasLocalEdits(true);
    dispatch(geocodeTypedLocation(text, 'end', { possiblyIncomplete: true }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    event.target.blur();

    dispatch(
      locationsSubmitted(
        startHasLocalEdits ? startText : startLocation,
        endHasLocalEdits ? endText : endLocation,
      ),
    );
  };

  const handleFocus = (which, event) => {
    dispatch(locationInputFocused());
    setFocusedInput(which);
  };

  const handleBlur = (event) => {
    // If the newly focused element is not part of the search bar (including
    // the autocomplete dropdown), set focused input to null (which hides the
    // autocomplete dropdown).
    if (!formRef.current.contains(event.relatedTarget)) {
      const previousFocusedInput = focusedInput;
      setFocusedInput(null);
      if (previousFocusedInput != null) dispatch(locationInputsBlurred());
    }
  };

  const handleAutocompleteClick = (which, point) => {
    dispatch(selectGeocodedLocation(which, point));

    if (which === 'start' && !endLocation) {
      endRef.current.focus();
    } else if (!startText && !startLocation) {
      startRef.current.focus();
    } else {
      // Make sure we don't think that the ending location input is still focused;
      // that could cause glitches down the road.
      endRef.current.blur();
      setFocusedInput(null);
    }
  };

  const handleKeyPress = (evt) => {
    if (evt.key === 'Enter') handleSubmit(evt);
  };

  return (
    <form className="SearchBar" onSubmit={handleSubmit} ref={formRef}>
      <span className="SearchBar_inputContainer">
        <Icon className="SearchBar_icon">
          <Pin />
        </Icon>
        <input
          aria-label="Starting point"
          className="SearchBar_input"
          type="text"
          placeholder="Starting point"
          value={displayedStart}
          onChange={handleStartChange}
          onFocus={handleFocus.bind(null, 'start')}
          onBlur={handleBlur}
          onKeyPress={handleKeyPress}
          ref={startRef}
        />
      </span>
      <span className="SearchBar_divider" />
      <span className="SearchBar_inputContainer">
        <Icon className="SearchBar_icon">
          <Pin />
        </Icon>
        <input
          aria-label="Destination"
          className="SearchBar_input"
          type="text"
          placeholder="Destination"
          value={displayedEnd}
          onChange={handleEndChange}
          onFocus={handleFocus.bind(null, 'end')}
          onBlur={handleBlur}
          onKeyPress={handleKeyPress}
          ref={endRef}
          autoFocus={props.initiallyFocusDestination}
        />
      </span>
      {focusedInput && (
        <SearchAutocompleteDropdown
          text={focusedInput === 'start' ? startText : endText}
          onResultClick={handleAutocompleteClick.bind(null, focusedInput)}
        />
      )}
    </form>
  );
}

function _describeLocation(loc) {
  if (!loc) return '';
  if (loc.source === LocationSourceType.UserGeolocation)
    return 'Current Location';
  if (loc.source === LocationSourceType.Marker) return 'Custom';
  return describePlace(loc.point);
}
